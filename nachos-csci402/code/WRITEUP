WRITEUP Template
 Title:  Writeup for Project 3, Fall 2015
 Date:  11/8/15
 Group: 26	Name	Email
		Conner Frey connerfr@usc.edu
		Hung Vu Viet vuviet@usc.edu
Yui Kwan Calvin Leung yuikwanl@usc.edu

I. Requirements:
- We will be investigating the use of caching by utilizing the TLB cache that is built into nachos.  Essentially, in project 2 we had a linear pageTable which allowed us to search for physical pages indexed by virtual addresses to figure out which pages in physical memory were being used.  This pageTable was unlimited and it could potentially map to all of the physical pages in main memory (RAM).  Unfortunately, this is really slow, because if we are looking for a physical page, all we have is the virtual page.  Thus we have to iterate through the entire page table just to find that out virtual page is not there, then we have to go onto the main memory or disk to access the physical page, which is really slow.  In project 3, we will be remedying these slow lookup steps through the IPT and the TLB.  In project 3 we must first write another case in exceptoin.cc to catch HandlePageFaultException.  The TLB is really fast––it’s a cache of size 4 which allows us to store recent translation entries into it.  When it fills up, we just overwrite the first entry.  If our desired virtual address is not in the TLB, we have to go to the next slowest data structure (but still faster than the page table or DISK), the IPT (inverted page table).  This data structure maps physical pages to virt pages while the page table maps virt pages to phys pages.  The IPT is the same size as main memory, but allows us to look for the physical page directly by checking for the virt page.  If the IPT is full, we need to evict a page from the IPT using either a random page eviction implementation or a queue eviction implementation.  If we evict something, we must check if that page is dirty.  If it is, we must write it to swap.  Otherwise, if the virt page is not in the IPT, we must look in the page table.  We must check if the phys page is in the swap file  or the executable file or neither, then we can read the page, and finally return it back to the IPT, update the IPT, and finally update the TLB.  This will allow use to have a fixed size of memory and imitate actual caching and memory management vs being allowed to have the program function with infinite memory.

The second part of the project is to implement Networking.  We must create server calls, a giant switch case, and a send and receive message handler in order to hook up clients to the server.  We must modify the current syscalls to send and receive encoded messages to implement synchronization code rather than using the locks and CVs already implemented in synch.h/.cc.  We will create protocols in order to abstractly send and handle message encoding both to and from the server.  We will create similar protocols on the Server in order to send and receive messages.  We will be supporting up to 5 clients with one server.  We implemented a giant server while loop in nettest.cc, and instantiated the packet header, mail header and buffer char.  We then start to receive messages from the post office, generated by client side applications.  The messages contain instructions such as “L C lock1”, which means Lock Create lock1 (name).  Then we compare the string to characters in the switch case which directly leads to the respective functions such as CreateLock, SetMonitor etc.  The server will be running forever and waiting to receive messages.  The to and from of packet headers and mail headers will be saved and populated to the correct recipient when stored in a waitqueue, so that when we remove from the queue, we send it to the correct client.  All these remote procedure calls enable us to create, destroy, get, set data, and do multi threading with locks, conditions and monitors.

The final integration will bring the networking and memory management together in order to run the networking using the tlb and ipt underbelly.

II. Assumptions:
	//- Reasonable assumptions you take for your scheme.
The infinite memory assumption is taken away in this assignment
When evicting a page from memory, we have to keep track of which process the page belongs to, and update the pagetable accordingly.
User programs should be using the syscalls at their own responsibility, our job is to make sure whatever they do, the functions will catch the bad conditions and return errors instead of crashing.
Postoffce works just fine to deliver and receive messages
There is a fixed maximum number of locks, conditions and monitor variables
The locks, conditions and monitors are “deleted” if the isDeleted flag is true, instead of having the whole object deleted, for convenience purpose
Locks and conditions and monitors are destroyed when they are not in use, i.e. if the user try to destroy them while in use, they will be destroyed once release or signal etc. are called.
All the locks and conditions and monitors are no longer used and created on the local process addressspace, and that part of the project2 is no longer available in project3
If the server is idle for a long period of time, the postoffce times out and is no longer able to function properly.  The assignment is built on the assumption that there are continuous message flows or short duration.

III. Design:
- This section is to cover your logic and ideas as to how you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.
exception.cc
We needed to add an if statement for PageFaultException which reads from the Bad Virtual Addr register. The register content is passed to HandlePageFault(), which contains the needed virtual address
void HandlePageFault(int virtualAddress) deals with the PageFaultException. It translates the virtual address into a virtual page and looks for that virtual page in the IPT table. If it finds the virtual page in the IPT table, it will pass the index/position of that index to the TLB, to be loaded in. If not, it will call the handleIPTMiss function, passing in the virtual page
int handleIPTMiss(int virtualPage) deals with not finding the needed virtual page in the IPT table. It will first try to look in available memory and see if there’s a free page to be filled in. If there isn’t, it will call the handleMemoryFull to free up a space in the memory. When available memory is found/returned, it will used to load the appropriate page from the executable or swap file, depending on the DiskLocation of the virtual page and the byte offset, and the pagetable and IPT table will be updated accordingly.
int handleMemoryFull() handles booting a page out of the limited memory. The memory is only 32 pages for this assignment, which is reflected by the size of the IPT table. Depending on argument input stored in runWithFIFO, it will either choose a random or FIFO page replacement policy for the memory. It will then choose a page, propagate the dirty bit from the TLB into the IPT page to be replaced. If a page is to be replaced, and the dirty bit is set in the IPT, we will store the page in the swapfile, and update the corrensponding page table accordingly. That freed page is now returned to handleIPTMiss.
exec in switch case has been modified to work with the new addrspace constructor
fork in switch case has been modified to work with the new NewPageTable function
helper functions such as sendMessageToClient, getFromServer, putMsgLock, putCondLock are written in order to help code reuse in our project
all the locks and conditions variables are commented out from addressspace, and placed into servers
From the client side, the message string are passed in with characters to encode the functions.  syscode1:‘L’, ‘C’, ‘M’ stand for Locks, Conditions, Monitors respectively  syscode2: ‘C’, ‘A’, ‘R’, ‘D’, ‘W’, ‘S’, ‘B’, ‘G’, ‘S’ stand for Create, Acquire, Release, Destroy, Wait, Signal, Broadcast, Get, Set respectively
We encapsulate the threads on the server with machineId and mailboxNum to ensure the program is the unique enough to be recognized
We also encode some of the strings to keep the machine id and mailbox numbers, e.g. “3 0 0 1” means to machineid 3, to mailbox 0, from mailbox 0
All the invalid actions, such as index over max allowed number, index over array size, waiting on an invalid lock, releasing before acquiring, accessing destroyed objects are handled properly with if else catch blocks.  The appropriate error messages are returned
We obtain the packetheaders and mailheaders and exchange the to and from fields in server before we send them back to the client or place the message on the queue
Then postOffice->send is used to send the messages



IV. Implementation:
Files modified
exception.cc
progtest.cc
custom_syscalls.h
lock_syscalls.cc
condition_syscalls.cc
nettest.cc
addrspace.cc
addrspace.h
system.cc
system.h
Makefiles
conditionServerInit.c
conditionServerTests.c
condtest.c
exectests.c
forktests.c
locktest.c
networkTestsuite.c
twoMatmults.c
testsend.c
condInit.c
condServer_t1.c
condServer_t2.c
condServer_t3.c
condServer_t4.c
monInit.c
monServer_t1.c
monServer_t2.c
lockInvalidTest.c
lock_t1.c
lock_t2.c

	+ Data Structures added, and the file they were added to.
system.cc:: class IptEntry
network.cc::struct ServerLock
network.cc::struct ServerCond
network.cc::struct ServerMon
nettest.cc::struct Msg
nettest.cc::struct ServerThread
system.h OpenFile *swapFile - pointer to the opened swap file
system.h BitMap* swapfileBitmap - pointer to the bitmap associated with the swapFile
system.h List* swapQueue - pointer to a list that will take care of the FIFO queue for swapping out pages
system.h bool runWithFIFO - a global boolean to indicate whether the page replacement policy is random or FIFO

	+ Data Structures modified, and the file they were added to.
addrspace.h has an OpenFile* executable variable
TranslationEntry was extended to ExtendedTranslationEntry, which holds int bytOffset and DiskLocation diskLocation in addrspace.h
DiskLocation is an enum, containing SWAP, EXECUTABLE, NEITHER in addrspace.h
system.h has IptEntry data structure, which extends TranslationEntry, adding int spaceOwner


+ Functions added and in which file.
- nettest.cc::operator==(const ServerLock& l1, const ServerLock& l2)
- to compare ServerLocks
- nettest.cc::bool validateLockIndex(int lockIndex)
- validate the lock index
- nettest.cc::bool validateMonitorIndex(int monitorIndex)
- validate the monitor index
- nettest.cc::bool validateConditionIndex(int conditionIndex)
- validate the conditionIndex
- nettest.cc::void sendMessageToClient(char* data, PacketHeader &pktHdr, MailHeader &mailHdr)
- send data to the client as specified by the pktHdr and mailHdr
- nettest.cc::void sendCreateEntityMessage(stringstream &ss, PacketHeader &pktHdr, MailHeader &mailHdr)
- send a message to the server when an entity is created i.e. CreateLock
- nettest.cc::void Signal_without_send(PacketHeader &pktHdr, MailHeader &mailHdr, char* data, int lockIndex)
	- this is a function for backend signaling, essentially the same as the signal syscall, but without the postoffice functions, just removing messages from queues and adding them to the acquire queue
- nettest.cc::void putMsgLock(PacketHeader &pktHdr, MailHeader &mailHdr, char* data, int lockIndex)
	- a helper function to add messages to a lock waitqueue
- nettest.cc::void putMsgCond(int lockIndex, int conditionIndex,  PacketHeader &pktHdr, MailHeader &mailHdr)
	- a helper function to add messages to a condition waitqueue
- nettest.cc::void Server()
- the while loop with a behemoth switch statement that catches all of the cases for various Server calls
- nettest.cc::void serverReleaseLock(int lockIndex, PacketHeader &pktHdr, MailHeader &mailHdr)
- the release function for wait, broadcast syscalls - without postoffice functions
- lock_syscalls.cc::void sendToServer()
- generic function that allows us to send any message to the server
- string getFromServer(PacketHeader &pktHdr, MailHeader &mailHdr)
- gets the encoded string message from the server
	+ Functions modified and in which file.

V. Testing:  (For each test case, you must show)
	+ How to test
- How to run the test cases, the commands, the arguments and so on.
	+ Test Output
- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output. The grader of your submission will be wanting to compare the output they get with what you say the output is.

Tests for part 1 and 2
The command line argument -P RAND or FIFO can be appended to any of the commands to test the respective page replacement policy, the default replacement policy is FIFO

+ Command: nachos -x ../test/matmult
+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 7220
Machine halting!
+ This tests runs the matmult test in the test directory to prove our memory management unit works. Expected output matches the exit statement.

+ Command: nachos -x ../test/sort
	+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 1023
Machine halting!
+ This tests runs the sort test in the test directory to prove our memory management unit works again, this test is more memory intensive and thoroughly tests the swapfile. Expected output matches the exit statement.

+ Command: nachos -x ../test/forkTwoMatmults
	+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 0
-----------Exit Output: 7220
-----------Exit Output: 7220
Machine halting!
+ This tests runs the forkTwoMatmults test in the test directory, which forks two matmults, which will exit with the expected output. Expected outputs matches the exit statements the forks return. Forks prove that we can ran multiple threads on the same address space.

+ Command: nachos -x ../test/forkTwoSorts
	+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 0
-----------Exit Output: 1023
-----------Exit Output: 1023
Machine halting!
+ This tests runs the forkTwoSorts test in the test directory, which forks two sorts, which will exit with the expected output. Expected outputs matches the exit statements the forks return. Proves that multiple forks can live in the same address space.

+ Command: nachos -x ../test/twoMatmults
	+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 0
Not last process and last thread, deleting process.
-----------Exit Output: 7220
Not last process and last thread, deleting process.
-----------Exit Output: 7220
Machine halting!
+ This tests runs the twoMatults test in the test directory, which Execs two matmult instances, which will exit with the expected output. Expected outputs matches the exit statements the forks return. This tests our address space collusions.

+ Command: nachos -x ../test/twoSorts
	+ Expected output:
Starting User Program.
Assigned space.
Accessing process table.
Saving processEntry.
-----------Exit Output: 0
Not last process and last thread, deleting process.
-----------Exit Output: 1023
Not last process and last thread, deleting process.
-----------Exit Output: 1023
Machine halting!
+ This tests runs the twoSorts test in the test directory, which Execs two sorts instances, which will exit with the expected output. Expected outputs matches the exit statements the forks return. This tests serves the same purpose as the previous test to prove address space for different processes work as they should.

Tests for part 3
******** To run these tests, have 4-6 aludra windows open, and run the tests with the -ct flag, e.g. nachos -x ../test/acquireTest -ct 1   The -ct flag gives the client a machineId, while the server is run by nachos -m 0  *********
LOCKS Test
+ $ nachos -x ../test/lockInvalidTest -ct 1
+$ nachos -x ../test/acquireTest -ct (2-6)
(lockInvalidTest output)
+lockInvalidTest is an initialization function with a set of basic testing functionalities, including sanity check tests for invalid indexes, permission to release, create and destroy locks etc.  Moreover, the test instantiates lock variables on the server, so that other tests can use the locks for ‘multithreaded’ functions.
In lockInvalidTest, we see that the userprogram creates a lock and acquires it twice, yielding two messages saying they got the lock and lock is already acquired.  Then we create more locks, with names such as lockToBeDestroyed. We also try to acquire, release, destroy a number out of bounds, theLockThatDoesntExist, and error messages are shown.
Afterwards, we will have to prepare to run acquireTest in 5 aludra terminals within a short time.  There is a Yield forloop which the userprogram tries to acquire a lock, and stops the test for a few seconds, so that all 5 userprograms can be placed on the lock waitqueue at the same time, and then be released one by one after the yield forloop is finished.  We see that all the functions work properly in locks.
Client::CreateLock:: 0
Acquire::receivedString: You got the lock!
Acquire::receivedString: Lock is yours. Done nothing.
Release::receivedString: You released the lock!
Client::CreateLock:: 1
Client::CreateLock:: 2
Client::CreateLock:: 3
Client::CreateLock:: 4
Client::CreateLock:: 5
Client::CreateLock:: 6
Testing invalid actions for locks
Acquiring theLockThatDoesntExist, should give error
Acquire::receivedString: Invalid lock index!
Releasing theLockThatDoesntExist, should give error
Release::receivedString: Invalid lock index!
Releasing lock1 before acquire, should give error
Release::receivedString: No permission to release!
Destroying theLockThatDoesntExist, should give error
DestroyLock::receivedString: Invalid lock index!
Destroying lockToBeDestroyed, should be successful
DestroyLock::receivedString: You destroyed the lock!
Finshing invalid test


Acquire::receivedString: You got the lock!
Release::receivedString: Released. Another thread took it.
Finshing acquireTest
-----------Exit Output: 0
Machine halting!

CONDITION Test
+ $ nachos -x ../test/condInit -ct 1
+$ nachos -x ../test/signalTest -ct (2-5)
+$ nachos -x ../test/condServer_t3 -ct (6)

Again, condInit is an initializing function which creates the condition and lock variables that we need for future tests and also test their basic error checking functionalities such as create, destroy, out of bounds check, doing something without acquiring a lock etc.  We first create locks and conditions, then try to destroy conditions normally and with out of bounds index.  Then we proceed to testing signal, wait and broadcast with invalid actions.

Creating test locks and CVs, should be successful
Client::CreateLock:: 0
Client::CreateLock:: 1
Client::CreateCondition::receivedString: 0
Client::CreateCondition::receivedString: 1
Client::CreateLock:: 2
Client::CreateLock:: 3
Client::CreateCondition::receivedString: 2
Client::CreateCondition::receivedString: 3
Client::CreateCondition::receivedString: 4
Destroying CV, should see both successful and unsuccesful attempts.
Destroying condToBeDestroyed
DestroyLock::receivedString: Condition is destroyed.
Destroying theCondThatDoesntExist
DestroyLock::receivedString: Invalid cond index!
Waiting theCondThatDoesntExist
Acquire::receivedString: You got the lock!
Client::Wait::receivedString: Invalid cond index!
Signaling theCondThatDoesntExist
Acquire::receivedString: You got the lock!
Client::Signal::receivedString: Invalid cond index!
Release::receivedString: You released the lock!
Broadcasting theCondThatDoesntExist
Client::Broadcast::receivedString: Invalid cond index!
Finshing condInit

For Signal test, we try to wait multiple conditions at the same time (depending on how many you would like to test, just run nachos -x ../test/signalTest -ct machineId) and then run nachos -x ../test/condServer_t3 -ct machineId
The condServer_t3 test is actually a broadcast function that signals all of the waiting threads.  With the same idea in mind, we can run the following to test our signal functions to make sure all create, wait, signal, broadcast, destroy work in multithreaded scenarios

+ $ nachos -x ../test/condInit -ct 1
+$ nachos -x ../test/signalTest -ct (2-5)
+$ nachos -x ../test/signalTestEnd -ct (6)

Acquire::receivedString: You got the lock!
Client::Wait::receivedString: You got the lock!
Release::receivedString: You released the lock!
Finshing signalTest




MONITOR Test
+ $ nachos -x ../test/monInit -ct 1
+$ nachos -x ../test/monServer_t1 -ct 2
+$ nachos -x ../test/monServer_t2 -ct 2
+$ nachos -x ../test/monServer_t3 -ct 2

Finally, we put together a small application that allows different userprograms to set and extract monitor variables, i.e. sharing data across the server.  We also use the locks and conditions functions which are already fully tested above in this little program.

As usual, we initialize the variables in monInit, and do basic functions such as creating, destroying, setting and getting.  We also print out the values for checking.
(monInit)
Creating monitors and locks
Client::CreateLock:: 0
Client::CreateLock:: 1
Client::CreateCondition::receivedString: 0
Client::CreateCondition::receivedString: 1
Setting Monitors 1 from 0-4, should be sucessful.
Client::SetMonitor::receivedString: Set monitor successfully! 1 0 0
Client::SetMonitor::receivedString: Set monitor successfully! 1 1 1
Client::SetMonitor::receivedString: Set monitor successfully! 1 2 2
Client::SetMonitor::receivedString: Set monitor successfully! 1 3 3
Client::SetMonitor::receivedString: Set monitor successfully! 1 4 4
Setting Monitors 2 from 5-9, with acquire and release, should be successful.
Acquire::receivedString: You got the lock!
Client::SetMonitor::receivedString: Set monitor successfully! 0 5 5
Client::SetMonitor::receivedString: Set monitor successfully! 0 6 6
Client::SetMonitor::receivedString: Set monitor successfully! 0 7 7
Client::SetMonitor::receivedString: Set monitor successfully! 0 8 8
Client::SetMonitor::receivedString: Set monitor successfully! 0 9 9
Release::receivedString: You released the lock!
Acquire::receivedString: You got the lock!
Client::GetMonitor::receivedString:
Printing monitor value. Should have 3.
3
Client::GetMonitor::receivedString:
Printing monitor value. Should have 5.
5
Release::receivedString: You released the lock!
Client::DestroyMonitor::receivedString: Deleted monitor successfully!
Client::DestroyMonitor::receivedString: Invalid monitor index!

Then we have a userprogram acquiring a lock and setting the monitor to number 9.  This number will act as the data shared on the server and another trusted userprogram will acquire the same lock and then obtain the piece of data.  There are also DestroyMonitor calls here.  Locks and condition wait are used here so that we can prove that all the syscalls work together to produce a functional userprogram with remote procedure calls

(monServer_t1)

Setting monitors
Acquire::receivedString: You got the lock!
Client::SetMonitor::receivedString: Set monitor successfully! 0 0 9
Release::receivedString: Released. Another thread took it.
Waiting on lock2
Acquire::receivedString: You got the lock!
Client::Wait::receivedString: You got the lock!
Release::receivedString: You released the lock!
Destroying Monitors 1 and 2
Client::DestroyMonitor::receivedString: Deleted monitor successfully!
Client::DestroyMonitor::receivedString: Deleted monitor successfully!

Another program getting the value 9, successfully sharing data.

(monServer_t2)
Acquiring and printing monitor value. Should have 9.
Acquire::receivedString: You got the lock!
9
Release::receivedString: Released. Another thread took it.

Just a third program trying to acquire and signal other threads with monitors.

(monServer_t3)
Acquiring and Signaling.
Acquire::receivedString: You got the lock!
Client::Signal::receivedString: Signalled
Release::receivedString: Released. Another thread took it.


VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
- For tests in parts 1 and 2, we expected the tests to run normally as they would have for project 2; the user program wouldn’t see any difference to how their syscalls execute, but on the kernel level, we have implemented a limited size memory of 32 pages. There’s also a swap file the kernel uses to write dirty pages to. The TLB, or the translation lookaside buffer can only load in 4 pages, and simulates our cache on the processor - a hardware component. Our memory is simulated with the IPT, which keeps track of pages in the IPT.
	+ Experiment result.  (What actually happened.)
- Syscalls tested were fork and exec for parts 1 and 2. These were used because both of these deal with stack size increasing and address space allocation. The forks and execs performed like the user expected, just took a little longer than in project 2 because our memory was no longer infinite.
	+ Explanation
		- Our result show that our implementation of the TLB table, IPT and swapfile worked well, because the userprogram doesn’t see a difference in syscall behaviour, but there’s a significant delay in behaviour because there are continuous TLB misses and IPT misses, for which NACHOS has to simulate loading the correct pages into the TLB from memory, and into the IPT and TLB from disk.


For tests in part 3, we expected the tests to run normally as project 2, aside from the new monitor syscalls.  It would be different as the syscalls are requested to a central server which routes the requests and send the messages.

We intensively tested all the basic functionalities of each locks and conditions syscalls, and made sure they work by first using unit tests.  Then, at the end of the tests, we have monitor tests which are both 1. multithreaded and 2. involves shared data and all the syscalls.  Which demonstrates the ability to make functional RPCs among userprogram clients and servers

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.

 Happy grading and thanks! (:
